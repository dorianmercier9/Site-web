[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Python",
    "section": "",
    "text": "Bienvenue sur le site Python Starter\n\n\n\nLogo Python\n\n\nBienvenue sur votre site d’apprentissage de Python !\nÀ propos du site\nNotre site est conçu pour les débutants qui souhaitent apprendre à programmer en Python de manière simple et efficace. Nous proposons une série de cours organisés de manière progressive pour vous guider à travers les concepts fondamentaux de la programmation en Python.\nLes Variables\nDans ce cours, vous apprendrez ce qu’est une variable en Python, comment les déclarer, les types de données qu’elles peuvent contenir, et comment les utiliser dans vos programmes.\nLes Types de Données\nCe cours vous introduira aux différents types de données disponibles en Python, tels que les entiers, les flottants, les chaînes de caractères, les listes, les tuples et les dictionnaires.\nLes Opérateurs\nDécouvrez les opérateurs arithmétiques, logiques et de comparaison en Python, ainsi que leur utilisation dans l’évaluation des expressions.\nLes Conditions\nDans ce cours, vous apprendrez à utiliser les instructions if, else et elif pour créer des structures de contrôle conditionnelles dans vos programmes.\nLes Boucles\nDécouvrez les boucles for et while en Python et apprenez à les utiliser pour itérer sur des séquences de données et exécuter des blocs de code répétitifs.\nLes Fonctions\nCe cours vous enseignera la création et l’utilisation de fonctions en Python pour encapsuler du code réutilisable et modulaire.\nLes Conversions\nApprenez à convertir des données entre différents types en Python, tels que la conversion de chaînes de caractères en nombres et vice versa.\nLes Modules\nDécouvrez comment utiliser des modules en Python pour organiser et réutiliser du code, ainsi que pour étendre les fonctionnalités de base du langage.\nExercices interactifs\nEn plus des cours théoriques, nous proposons également des exercices interactifs pour chaque cours afin que vous puissiez mettre en pratique ce que vous avez appris. La pratique est essentielle pour maîtriser Python, alors n’hésitez pas à vous entraîner et à expérimenter avec le code !\nCommencez dès maintenant votre parcours d’apprentissage en explorant nos cours et en vous lançant dans les exercices interactifs. Bonne chance et bon apprentissage !"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Python",
    "section": "",
    "text": "LES VARIABLES\n\n\n\nVariables Python\n\n\nLes variables sont des conteneurs permettant de stocker des valeurs de données, telles que des nombres ou des chaînes de caractères.\n\nAffectation (=).\nPython détermine automatiquement le type de données en fonction de la valeur attribuée.\nEcraser les valeurs des variables en les réaffectant.\nSensible à la casse : “X” et “x” sont deux variables différentes\nImprimer plusieurs variables dans une seule instruction print avec (,)\nPlusieurs valeurs à plusieurs variables ou plusieurs variables à une seule valeur sur une seule ligne.\nDénomination des variables incluent :\n\nla casse camel : testVariableCase\nla casse Pascal : TestVariableCase\nla casse serpent : test_variable_case\n\nEvitez de:\n\ncommencer les noms de variables par des chiffres\nutiliser des symboles tels que des tirets ou des espaces\nmélanger des chaînes de caractères et des nombres entiers directement dans la concaténation.\n\n\nx = 10\nprint(x)\ntype(x)\n10\nint\ny = \"carbonara\"\nprint(y)\ntype(y)\ncarbonara\nstr\n# y != Y\nY = \"Pates à la carbonara\"\nprint(Y)\nPates à la carbonara\n# affectation de valeurs différentes\nx, y, z = \"Carbonara\", \"Bolognaise\", \"Pesto\"\nprint(x)\nprint(y)\nprint(z)\nCarbonara Bolognaise Pesto\n# affectation de la même valeur\nx = y = z = \"Carbonara\"\nprint(x)\nprint(y)\nprint(z)\nCarbonara Carbonara Carbonara\n# creation une liste et affectation\npates = []\npates = [\"Carbonara\", \"Bolognaise\", \"Pesto\"]\nx, y, z = pates\nprint(x)\nprint(y)\nprint(z)\nCarbonara Bolognaise Pesto\n# concatenation : seulement chaine de caractère ensemble\nx = \"Les pates à la \" + 'carbonara sont mes préférées'\nprint(x)\nLes pates à la carbonara sont mes préférées\nx = \"Les pates\"\ny = \"à la carbonara\"\nz = \"sont mes préférées\"\nprint(x, y, z)\nLes pates à la carbonara sont mes préférées\nx = 2\ny = 3\nz = 4\nprint(x+y+z)\n9\n# La f-string ? \n\nnom = \"Dubalcon\"\nprenom = \"Jean\"\nage = 55\n\nprint(f\"Bonjour, je m'appelle {prenom} {nom} et j'ai {age} ans.\")\nBonjour, je m’appelle Jean Dubalcon et j’ai 55 ans."
  },
  {
    "objectID": "index.html#bienvenue-sur-le-site-python-visualisation-explorez-la-data-visualisation-avec-pandas",
    "href": "index.html#bienvenue-sur-le-site-python-visualisation-explorez-la-data-visualisation-avec-pandas",
    "title": "Commencez votre voyage dès maintenant et laissez-vous inspirer par le pouvoir de la data visualisation !",
    "section": "",
    "text": "Dans un monde où les données abondent et où l’analyse de données est devenue cruciale dans de nombreux domaines, la capacité à visualiser et à interpréter ces données est essentielle. La data visualisation offre un moyen puissant de comprendre les tendances, les modèles et les relations cachées dans les données, facilitant ainsi la prise de décisions éclairées.\nSur ce site, nous vous invitons à plonger dans l’univers fascinant de la data visualisation avec Pandas, une bibliothèque Python largement utilisée pour l’analyse de données. À travers des tutoriels simples et des exemples pratiques, vous découvrirez comment utiliser Pandas dans l’environnement de développement intégré (IDE) Visual Studio Code (VS Code) pour créer des visualisations percutantes à partir de vos données.\nQue vous soyez un débutant curieux ou un utilisateur expérimenté cherchant à approfondir vos connaissances, ce site est conçu pour vous accompagner à chaque étape de votre voyage dans le monde de la data visualisation. De la manipulation des données avec Pandas à la création de graphiques informatifs et esthétiques, vous apprendrez les compétences nécessaires pour transformer des données brutes en visualisations significatives.\nPréparez-vous à explorer les différentes fonctionnalités de Pandas, à découvrir les techniques avancées de data visualisation et à maîtriser l’art de communiquer efficacement à travers les données. Que ce soit pour des projets professionnels, des analyses personnelles ou simplement par passion pour les données, ce site sera votre guide pour exploiter tout le potentiel de la data visualisation avec Pandas dans VS Code."
  },
  {
    "objectID": "types.html",
    "href": "types.html",
    "title": "Types de données",
    "section": "",
    "text": "Types de données en Python\n\n\nLes types de données en Python classent les données et déterminent les opérations autorisées.\n\nDonnées numériques : les entiers, les flottants et les nombres complexes.\nDonnées booléennes, deux valeurs : Vrai et Faux.\nDonnées séquentielles : les chaînes, les listes et les tuples.\n\nLes chaînes de caractères sont indexées, l’indexation commençant à 0. Elles peuvent être placées entre guillemets simples, doubles ou triples.\nLes listes stockent plusieurs valeurs, séparées par des virgules, et peuvent contenir différents types de données.\nLes tuples sont similaires aux listes mais sont immuables, ce qui signifie qu’ils ne peuvent pas être modifiés après leur création.\nLes ensembles sont des collections non ordonnées de valeurs uniques et sont utiles pour la recherche de valeurs uniques et les opérations sur les ensembles.\nLes dictionnaires reposent sur des paires clé-valeur pour stocker des données, et les valeurs sont accessibles à l’aide des clés. Les dictionnaires sont mutables, autorisant les mises à jour et les suppressions. ]()\n\n\n# entier\ntype(-10 + 50)\nint\n# float\ntype(-10 + 50.4)\nfloat\n# complexe ! fonctionne que avec j pas i !\ntype(10+ 3j)\ncomplex\ntype(False)\ntype(True)\ntype(2&gt;5)\n2&gt; 5\n2&lt;5\n2 == 2\nbool\n# chaines\n'Simple'\n\"Double\"\nligneMultiple = \"\"\"\nPour la rédaction d'une chaine de caractére sur \nplusieurs lignes\n\"\"\"\nprint(ligneMultiple)\ntype(ligneMultiple)\nPour la rédaction d’une chaine de caractére sur plusieurs lignes\nstr\n# Attention : utiliser une double quote lorsque qu'il y a des apostrophes dans une phrase\n# print('J'ai 15 ans')\nprint(\"J'ai faim\")\n# Attention : utiliser une double quote lorsque qu'il y a des apostrophes dans une phrase\n# print('J'ai 15 ans')\nprint(\"J'ai faim\")\na =  \"Bonjour Paris\"\nprint(a[0:6])\nprint(a[-3]) # a l'inverse\nprint(a[2:5])\nBonjour r njour\na*3\nBonjour ParisBonjour ParisBonjour Paris\na+ '  ' +a\nBonjour Paris Bonjour Paris\n# liste : on peut tout mettre dans une liste\n[1, 2, 3]\n[\"Pates\", 3, \"Fourchettes\", True, [\"a\", \"b\"]]\n[‘Pates’, 3, ‘Fourchettes’, True, [‘a’, ‘b’]]\n# Ajout\npates = [\"Bolognaise\", \"Carbonara\", \"Pesto\"]\npates.append(\"Nature\")\npates\n[‘Bolognaise’, ‘Carbonara’, ‘Pesto’, ‘Nature’]\n# Ajout\n#changer l'ordre\npates[0] = \"Nature\"\npates[3] = \"Carbonara\"\npates\n[‘Pistache’, ‘Chocolat’, ‘Fraise’, ‘Vanille’]\nlistList = [\"Pates\", 3, \"Fourchettes\", True, [\"a\", \"b\"]] # nested list\nlistList[4]\nlistList[4][1]\n‘b’\ntest = [1,4, 90]\ntest.remove(1)\ntest.append(34)\nhelp(list) # toutes les méthodes\nHelp on class list in module builtins:\nclass list(object) | list(iterable=(), /) | | Built-in mutable sequence. | | If no argument is given, the constructor creates a new empty list. | The argument must be an iterable if specified. | | Methods defined here: | | add(self, value, /) | Return self+value. | | contains(self, key, /) | Return bool(key in self). | | delitem(self, key, /) | Delete self[key]. | | eq(self, value, /) | Return self==value. | | ge(self, value, /) … | Data and other attributes defined here: | | hash = None\n# longueur d'une liste\nlen(test)\n3\n# tuple : ne change jamais (data pour ce qui ne change jamais)\nexempleTuple = (1, 2, 3, 1, \"a\")\nexempleTuple[1] # avec un index mais pas modifiable\n# exempleTuple[0] = \"test\" # mais pas modifiable\n2\n# sets : comme liste et tuple mais pas d'index l'avantage est qu'il n'affiche que les valeur unique\nensembleSet = {1, 3, 90, \"test\", 3}\nprint(ensembleSet)\n{1, 90, 3, ‘test’}\n# utile pour comparer deux sets.\nset1 = {2, 3, 5, 80, 23}\nset2 = {1, 2, 3, 10, 80}\nprint(set1 | set2) # unique en combinant les deux sets\nprint(set1 & set2) # présent dans les deux\nprint(set1 - set2) # ce qui ne matche pas entre les deux sets\nprint(set1 ^ set2) # unique dans l'un ou l'autre\n{1, 2, 3, 5, 10, 80, 23} {80, 2, 3} {5, 23} {1, 5, 23, 10}\n# dictionnaires\n# clé/valeur\ndico = {'nom': 'Dorian', 'age': 26 , 'pates préférées' : 'Carbonara'}\ntype(dico)\ndict\ndico.keys()\ndict_keys([‘nom’, ‘age’, ‘pates préférées’])\ndico.values()\ndict_values([‘Dorian’, 26, ‘Carbonara’])\ndico.items()\ndict_items([(‘nom’, ‘Dorian’), (‘age’, 26), (‘pates préférées’, ‘Carbonara’)])\ndico['nom'] # index par la clef\n‘Dorian’\ndico['nom'] = \"Michel\"\ndico\n{‘nom’: ‘Michel’, ‘age’: 26, ‘pates préférées’: ‘Carbonara’}\ndico.update({'nom': 'Dorian', 'age': 26 , 'poids' : '70kg'})\ndico\n{‘nom’: ‘Dorian’, ‘age’: 26, ‘pates préférées’: ‘Carbonara’, ‘poids’: ‘70kg’}\ndel dico['poids']\ndico\n{‘nom’: ‘Dorian’, ‘age’: 26, ‘pates préférées’: ‘Carbonara’}\nvar  = 2\nprint(isinstance(var, int))\nTrue"
  },
  {
    "objectID": "types.html#types-de-données",
    "href": "types.html#types-de-données",
    "title": "Python",
    "section": "",
    "text": "Types de données en Python\n\n\nLes types de données en Python classent les données et déterminent les opérations autorisées.\n\nDonnées numériques : les entiers, les flottants et les nombres complexes.\nDonnées booléennes, deux valeurs : Vrai et Faux.\nDonnées séquentielles : les chaînes, les listes et les tuples.\n\nLes chaînes de caractères sont indexées, l’indexation commençant à 0. Elles peuvent être placées entre guillemets simples, doubles ou triples.\nLes listes stockent plusieurs valeurs, séparées par des virgules, et peuvent contenir différents types de données.\nLes tuples sont similaires aux listes mais sont immuables, ce qui signifie qu’ils ne peuvent pas être modifiés après leur création.\nLes ensembles sont des collections non ordonnées de valeurs uniques et sont utiles pour la recherche de valeurs uniques et les opérations sur les ensembles.\nLes dictionnaires reposent sur des paires clé-valeur pour stocker des données, et les valeurs sont accessibles à l’aide des clés. Les dictionnaires sont mutables, autorisant les mises à jour et les suppressions. ]()"
  },
  {
    "objectID": "operators.html",
    "href": "operators.html",
    "title": "Python",
    "section": "",
    "text": "Les Opérateurs\n\n\n\nLogo operateurs\n\n\nLes opérateurs Python sont utilisés pour effectuer des opérations sur les variables et les valeurs.\nLes opérateurs de comparaison en Python incluent égal à, différent de, supérieur à, inférieur à, supérieur ou égal à, et inférieur ou égal à.\n\n\n\nOpérateur comparaison\nDescription\n\n\n\n\nEgalité\n==\n\n\nDifférent de\n!=\n\n\nSupérieur\n&gt;\n\n\nInférieur\n&lt;\n\n\nSupérieur ou égale\n&gt;=\n\n\nInférieur ou égale\n&lt;=\n\n\n\n\nRenvoient soit Vrai, soit Faux, en fonction du résultat de la comparaison.\n\nLes opérateurs logiques et, ou et non sont souvent combinés avec les opérateurs de comparaison.\n\n\n\nOpérateur logique\nDescription\nRésultat\n\n\n\n\nAnd\nand\nTrue si les deux propositions sont vraies\n\n\nOr\nor\nTrue si au moins une des propositions est Vraie\n\n\nNot\nnot\ninverse de l’instruction\n\n\n\nLes opérateurs d’appartenance in et not in sont utilisés pour vérifier si une valeur ou une chaîne de caractères se trouve à l’intérieur d’une autre valeur, chaîne de caractères ou séquence.\n\n\n\n\n\n\n\n\nOpérateur logique\nDescription\nRésultat\n\n\n\n\nIn\nin\nTrue si la valeur spécifiée est présente dans l’objet.\n\n\nNot in\nnot in\nTrue si la valeur spécifiée n’est pas présente dans l’objet.\n\n\n\n# comparaison\n10 == 10\n10 == 50\n10 != 50\n'Vanille' == 'Chocolat'\n'Vanille' != 'vanille'\n10 &lt; 50\nTrue\n# Logique\nnot (10 &gt; 50 ) and (50 &gt; 10)\nTrue\n# Logique\nnot (10 &gt; 50 ) and (50 &gt; 10)\nTrue\n(10 &gt; 50 ) or (50 &gt; 10)\nTrue\nchaine = 'Lucas aime le chocolat'\n'chocolat' in chaine\nTrue\nliste = [1, 4, 5, 50]\n40 not in liste\nTrue"
  },
  {
    "objectID": "operateurs.html",
    "href": "operateurs.html",
    "title": "Python",
    "section": "",
    "text": "Les Opérateurs\n\n\n\nLogo operateurs\n\n\nLes opérateurs Python sont utilisés pour effectuer des opérations sur les variables et les valeurs.\nLes opérateurs de comparaison en Python incluent égal à, différent de, supérieur à, inférieur à, supérieur ou égal à, et inférieur ou égal à.\n\n\n\nOpérateur comparaison\nDescription\n\n\n\n\nEgalité\n==\n\n\nDifférent de\n!=\n\n\nSupérieur\n&gt;\n\n\nInférieur\n&lt;\n\n\nSupérieur ou égale\n&gt;=\n\n\nInférieur ou égale\n&lt;=\n\n\n\n\nRenvoient soit Vrai, soit Faux, en fonction du résultat de la comparaison.\n\nLes opérateurs logiques et, ou et non sont souvent combinés avec les opérateurs de comparaison.\n\n\n\nOpérateur logique\nDescription\nRésultat\n\n\n\n\nAnd\nand\nTrue si les deux propositions sont vraies\n\n\nOr\nor\nTrue si au moins une des propositions est Vraie\n\n\nNot\nnot\ninverse de l’instruction\n\n\n\nLes opérateurs d’appartenance in et not in sont utilisés pour vérifier si une valeur ou une chaîne de caractères se trouve à l’intérieur d’une autre valeur, chaîne de caractères ou séquence.\n\n\n\n\n\n\n\n\nOpérateur logique\nDescription\nRésultat\n\n\n\n\nIn\nin\nTrue si la valeur spécifiée est présente dans l’objet.\n\n\nNot in\nnot in\nTrue si la valeur spécifiée n’est pas présente dans l’objet.\n\n\n\n# comparaison\n100 == 100\nTrue\n100 == 500\nFalse\n100 != 500\nTrue\n'Carbonara' == 'Bolognaise'\nFalse\n'Carbonara' != 'carbonara'\n10 &lt; 50\nTrue\n# Logique\nnot (100 &gt; 500 ) and (500 &gt; 100)\nTrue\n(100 &gt; 500 ) or (500 &gt; 100)\nTrue\n(100 &gt; 500 ) or (500 &gt; 100)\nTrue\nliste = [1, 4, 5, 50]\n40 not in liste\nTrue"
  },
  {
    "objectID": "variables.html",
    "href": "variables.html",
    "title": "Python",
    "section": "",
    "text": "LES VARIABLES\n\n\n\nVariables Python\n\n\nLes variables sont des conteneurs permettant de stocker des valeurs de données, telles que des nombres ou des chaînes de caractères.\n\nAffectation (=).\nPython détermine automatiquement le type de données en fonction de la valeur attribuée.\nEcraser les valeurs des variables en les réaffectant.\nSensible à la casse : “X” et “x” sont deux variables différentes\nImprimer plusieurs variables dans une seule instruction print avec (,)\nPlusieurs valeurs à plusieurs variables ou plusieurs variables à une seule valeur sur une seule ligne.\nDénomination des variables incluent :\n\nla casse camel : testVariableCase\nla casse Pascal : TestVariableCase\nla casse serpent : test_variable_case\n\nEvitez de:\n\ncommencer les noms de variables par des chiffres\nutiliser des symboles tels que des tirets ou des espaces\nmélanger des chaînes de caractères et des nombres entiers directement dans la concaténation.\n\n\nx = 2\nprint(x)\ntype(x)\n2\nint\ny = \"chocolat\"\nprint(y)\ntype(y)\nchocolat\nstr\nY = \"Glace au chocolat\"\nprint(Y)\nGlace au chocolat\n# affectation de valeurs différentes\nx, y, z = \"Chocolat\", \"Vanille\", \"Fraise\"\nprint(x)\nprint(y)\nprint(z)\nChocolat Vanille Fraise\n# affectation de valeurs différentes\nx, y, z = \"Chocolat\", \"Vanille\", \"Fraise\"\nprint(x)\nprint(y)\nprint(z)\nChocolat Chocolat Chocolat\n# affectation de valeurs différentes\n# creation une liste et affectation\nglaces = []\nglaces = [\"Chocolat\", \"Vanille\", \"Fraise\"]\nx, y, z = glaces\nprint(x)\nprint(y)\nprint(z)\nChocolat Vanille Fraise\n# concatenation : seulement chaine de caractère ensemble\nx = \"La glace à la \" + 'vanille est ma préférée'\nprint(x)\nLa glace à la vanille est ma préférée\nx = \"La glace\"\ny = \"à la vanille\"\nz = \"est ma préférée\"\nprint(x, y, z)\nLa glace à la vanille est ma préférée\nx = 1\ny = 2\nz = 3\nprint(x+y+z)\n6\n# La f-string ? \n\nnom = \"Dupont\"\nprenom = \"Jean\"\nage = 30\n\nprint(f\"Bonjour, je m'appelle {prenom} {nom} et j'ai {age} ans.\")\nBonjour, je m’appelle Jean Dupont et j’ai 30 ans."
  },
  {
    "objectID": "exo.html",
    "href": "exo.html",
    "title": "Exercices",
    "section": "",
    "text": "Description de l’exercice 2 sur les variables.\n\n\n\n\n\n\nDescription de l’exercice 1 sur les types de données.\n\n\n\nDescription de l’exercice 2 sur les types de données.\n\n\n\n\n\n\nDescription de l’exercice 1 sur les opérateurs.\n\n\n\nDescription de l’exercice 2 sur les opérateurs.\n\n\n\n\n\n\nDescription de l’exercice 1 sur les conditions.\n\n\n\nDescription de l’exercice 2 sur les conditions."
  },
  {
    "objectID": "exo.html#variables",
    "href": "exo.html#variables",
    "title": "Exercices",
    "section": "",
    "text": "Description de l’exercice 2 sur les variables."
  },
  {
    "objectID": "exo.html#types-de-données",
    "href": "exo.html#types-de-données",
    "title": "Exercices",
    "section": "",
    "text": "Description de l’exercice 1 sur les types de données.\n\n\n\nDescription de l’exercice 2 sur les types de données."
  },
  {
    "objectID": "exo.html#opérateurs",
    "href": "exo.html#opérateurs",
    "title": "Exercices",
    "section": "",
    "text": "Description de l’exercice 1 sur les opérateurs.\n\n\n\nDescription de l’exercice 2 sur les opérateurs."
  },
  {
    "objectID": "exo.html#conditions",
    "href": "exo.html#conditions",
    "title": "Exercices",
    "section": "",
    "text": "Description de l’exercice 1 sur les conditions.\n\n\n\nDescription de l’exercice 2 sur les conditions."
  },
  {
    "objectID": "conditions.html",
    "href": "conditions.html",
    "title": "Python",
    "section": "",
    "text": "Les conditions\n\n\nUne instruction “if else” en Python vous permet d’exécuter différents blocs de code en fonction de conditions. Il est essentiel de comprendre les instructions “if else” pour contrôler le flux de vos programmes Python en fonction de différentes conditions.\n\nL’instruction if vérifie si une condition est vraie et, si c’est le cas, elle exécute un bloc de code spécifique.\nL’instruction else spécifie un bloc de code à exécuter si la condition “if” initiale est fausse.\nVous pouvez avoir plusieurs instructions elif (else if) en plus des instructions initiales “if” et “else”.\nVous pouvez utiliser des opérateurs logiques tels que and et or dans les conditions “if” pour évaluer plusieurs conditions simultanément.\nLes instructions if imbriquées peuvent être utilisées pour créer des structures logiques plus complexes.\nEcrire des instructions if else en 1 ligne our les cas simples.\n\nif 30 &lt; 15:\n    print(\"if marche\")\nelse:\n    print(\"else fonctionne\")\nelse fonctionne\nif 30 &lt; 15:\n    print(\"if marche\")\nelif 25 &lt; 30:\n    print(\"elif fonctionne\")\nelse:\n     print(\"else fonctionne\")\nelif fonctionne\nif 30 &lt; 15:\n    print(\"if marche\")\nelif 25 &lt; 30:\n    print(\"elif1 fonctionne\") \nelif 25 &lt; 50:\n    print(\"elif2 fonctionne\")\nelse:\n     print(\"else fonctionne\")\nelif1 fonctionne\nif (25 &lt; 10) or (10 &lt; 90):  \n    print(\"if marche\")\nelif 25 &lt; 30:\n    print(\"elif1 fonctionne\")\nelif 25 &lt; 50:\n    print(\"elif2 fonctionne\")\nelse:\n     print(\"else fonctionne\")\nif marche\nprint(\"if fonctionne\") if 10 &gt; 30 else print(\"else fonctionne\")\nelse fonctionne\nif (25 &lt; 10) or (10 &lt; 90):  \n    print(\"if marche\")\n    if (90 &gt; 30):\n        print(\"if imbriqué marche aussi\")\n    else:\n        print(\"else imbriqué fonctionne\")\nelif 25 &lt; 30:\n    print(\"elif1 fonctionne\")\nelif 25 &lt; 50:\n    print(\"elif2 fonctionne\")\nelse:\n     print(\"else fonctionne\")\nif marche if imbriqué marche aussi\n# Introduction au case \ndef switch(mois):\n  if mois == 1:\n    return 'Janvier'\n  elif mois == 2:\n    return 'Fevrier'\n  elif mois == 3:\n    return 'Mars'\n  elif mois == 4:\n    return 'Avril'\n  elif mois == 5:\n    return 'Mai'\n  elif mois == 6:\n    return 'Juin'\n  elif mois == 7:\n    return 'Juillet'\n  elif mois == 8:\n    return 'Aout'\n  elif mois == 9:\n    return 'Septembre'\n  elif mois == 10:\n    return 'Octobre'\n  elif mois == 11:\n    return 'Novembre'\n  elif mois == 12:\n    return 'Decembre'\n  else:\n    return \"Pas un mois de l'année\"\n\nswitch(8)\n‘Aout’\n# match-case en Python\ndef switchMatch(jour):\n    match jour: \n        case 1:\n            return 'Janvier'\n        case 2:\n            return 'Fevrier'\n        case 3:\n            return 'Mars'\n        case 4:\n            return 'Avril'\n        case 5:\n            return 'Mai'\n        case 6:\n            return 'Juin'\n        case 7:\n            return 'Juillet'\n        case 8:\n            return 'Aout'\n        case 9:\n            return 'Septembre'\n        case 10:\n            return 'Octobre'\n        case 11:\n            return 'Novembre'\n        case 12:\n            return 'Decembre'\n        case _:\n            return \"Pas un mois de l'année\"\n        \nprint(switch(4), switchMatch(9))\nAvril Septembre"
  },
  {
    "objectID": "conditions.html#les-conditions-if-elif-else",
    "href": "conditions.html#les-conditions-if-elif-else",
    "title": "Python",
    "section": "",
    "text": "Les conditions\n\n\nUne instruction “if else” en Python vous permet d’exécuter différents blocs de code en fonction de conditions. Il est essentiel de comprendre les instructions “if else” pour contrôler le flux de vos programmes Python en fonction de différentes conditions.\n\nL’instruction if vérifie si une condition est vraie et, si c’est le cas, elle exécute un bloc de code spécifique.\nL’instruction else spécifie un bloc de code à exécuter si la condition “if” initiale est fausse.\nVous pouvez avoir plusieurs instructions elif (else if) en plus des instructions initiales “if” et “else”.\nVous pouvez utiliser des opérateurs logiques tels que and et or dans les conditions “if” pour évaluer plusieurs conditions simultanément.\nLes instructions if imbriquées peuvent être utilisées pour créer des structures logiques plus complexes.\nEcrire des instructions if else en 1 ligne our les cas simples.\n\nif 30 &lt; 15:\n    print(\"if marche\")\nelse:\n    print(\"else fonctionne\")\nelse fonctionne\nif 30 &lt; 15:\n    print(\"if marche\")\nelif 25 &lt; 30:\n    print(\"elif fonctionne\")\nelse:\n     print(\"else fonctionne\")\nelif fonctionne\nif 30 &lt; 15:\n    print(\"if marche\")\nelif 25 &lt; 30:\n    print(\"elif1 fonctionne\") \nelif 25 &lt; 50:\n    print(\"elif2 fonctionne\")\nelse:\n     print(\"else fonctionne\")\nelif1 fonctionne\nif (25 &lt; 10) or (10 &lt; 90):  \n    print(\"if marche\")\nelif 25 &lt; 30:\n    print(\"elif1 fonctionne\")\nelif 25 &lt; 50:\n    print(\"elif2 fonctionne\")\nelse:\n     print(\"else fonctionne\")\nif marche\nprint(\"if fonctionne\") if 10 &gt; 30 else print(\"else fonctionne\")\nelse fonctionne\nif (25 &lt; 10) or (10 &lt; 90):  \n    print(\"if marche\")\n    if (90 &gt; 30):\n        print(\"if imbriqué marche aussi\")\n    else:\n        print(\"else imbriqué fonctionne\")\nelif 25 &lt; 30:\n    print(\"elif1 fonctionne\")\nelif 25 &lt; 50:\n    print(\"elif2 fonctionne\")\nelse:\n     print(\"else fonctionne\")\nif marche if imbriqué marche aussi\n# Introduction au case \ndef switch(mois):\n  if mois == 1:\n    return 'Janvier'\n  elif mois == 2:\n    return 'Fevrier'\n  elif mois == 3:\n    return 'Mars'\n  elif mois == 4:\n    return 'Avril'\n  elif mois == 5:\n    return 'Mai'\n  elif mois == 6:\n    return 'Juin'\n  elif mois == 7:\n    return 'Juillet'\n  elif mois == 8:\n    return 'Aout'\n  elif mois == 9:\n    return 'Septembre'\n  elif mois == 10:\n    return 'Octobre'\n  elif mois == 11:\n    return 'Novembre'\n  elif mois == 12:\n    return 'Decembre'\n  else:\n    return \"Pas un mois de l'année\"\n\nswitch(8)\n‘Aout’\n# match-case en Python\ndef switchMatch(jour):\n    match jour: \n        case 1:\n            return 'Janvier'\n        case 2:\n            return 'Fevrier'\n        case 3:\n            return 'Mars'\n        case 4:\n            return 'Avril'\n        case 5:\n            return 'Mai'\n        case 6:\n            return 'Juin'\n        case 7:\n            return 'Juillet'\n        case 8:\n            return 'Aout'\n        case 9:\n            return 'Septembre'\n        case 10:\n            return 'Octobre'\n        case 11:\n            return 'Novembre'\n        case 12:\n            return 'Decembre'\n        case _:\n            return \"Pas un mois de l'année\"\n        \nprint(switch(4), switchMatch(9))\nAvril Septembre"
  },
  {
    "objectID": "conversion.html",
    "href": "conversion.html",
    "title": "Python",
    "section": "",
    "text": "Conversion\n\n\nPython vous permet de modifier facilement les types de données afin de manipuler et de travailler efficacement.\n# caractere -&gt; entier\nnum_str = \"50\"\nnum_int = 50\n# num_int + num_str # ne fonctionne\nnum_int + int(num_str) # fonctionne\n100\n# liste -&gt; tuple\nliste = [1, 3, 8]\ntuple_la_liste = tuple(liste)\ntype(tuple_la_liste)\ntuple\n# liste -&gt; set\nset_la_liste = set(liste)\ntype(set_la_liste)\nset\n# dictionnaire -&gt; liste\ndico = {'nom': 'Dorian', 'age': 26 , 'pates préférées' : ['Carbonara','Pesto']}\nliste_cle = list(dico.keys())\nliste_valeur =  list(dico.values())\nprint(liste_cle)\nprint(liste_valeur)\n[‘nom’, ‘age’, ‘pates préférées’] [‘Dorian’, 26, [‘Carbonara’, ‘Pesto’]]\n# chaine -&gt; liste\nchaine = \"J'aime les pizzas\"\nliste_chaine = list(chaine)\nprint(liste_chaine)\n[‘J’, “‘“, ’a’, ‘i’, ‘m’, ‘e’, ’ ‘, ’l’, ‘e’, ‘s’, ’ ‘, ’p’, ‘i’, ‘z’, ‘z’, ‘a’, ‘s’]"
  },
  {
    "objectID": "conversion.html#conversion-de-type-de-données",
    "href": "conversion.html#conversion-de-type-de-données",
    "title": "Python",
    "section": "",
    "text": "Conversion\n\n\nPython vous permet de modifier facilement les types de données afin de manipuler et de travailler efficacement.\n# caractere -&gt; entier\nnum_str = \"50\"\nnum_int = 50\n# num_int + num_str # ne fonctionne\nnum_int + int(num_str) # fonctionne\n100\n# liste -&gt; tuple\nliste = [1, 3, 8]\ntuple_la_liste = tuple(liste)\ntype(tuple_la_liste)\ntuple\n# liste -&gt; set\nset_la_liste = set(liste)\ntype(set_la_liste)\nset\n# dictionnaire -&gt; liste\ndico = {'nom': 'Dorian', 'age': 26 , 'pates préférées' : ['Carbonara','Pesto']}\nliste_cle = list(dico.keys())\nliste_valeur =  list(dico.values())\nprint(liste_cle)\nprint(liste_valeur)\n[‘nom’, ‘age’, ‘pates préférées’] [‘Dorian’, 26, [‘Carbonara’, ‘Pesto’]]\n# chaine -&gt; liste\nchaine = \"J'aime les pizzas\"\nliste_chaine = list(chaine)\nprint(liste_chaine)\n[‘J’, “‘“, ’a’, ‘i’, ‘m’, ‘e’, ’ ‘, ’l’, ‘e’, ‘s’, ’ ‘, ’p’, ‘i’, ‘z’, ‘z’, ‘a’, ‘s’]"
  },
  {
    "objectID": "fonctions.html",
    "href": "fonctions.html",
    "title": "Python",
    "section": "",
    "text": "Les boucles\n\n\nles fonctions sont des blocs de code qui sont exécutés lorsque vous les appelez. Vous pouvez personnaliser les fonctions pour qu’elles effectuent différentes tâches en leur passant différents arguments.\n\nDéfinies à l’aide du mot-clé **“def”*, suivi du nom de la fonction et de parenthèses.\nPasser des arguments aux fonctions pour fournir des valeurs d’entrée.\nLes arguments arbitraires et les mots-clés arbitraires sont utilisés lorsque vous ne savez pas à l’avance combien d’arguments vous allez passer.\n\narguments arbitraires, utilisez *args\nmots-clés arbitraires, utilisez **kwargs.\n\nChaque fonction doit être responsable d’une seule et unique fonctionnalité, et rien de plus.\n\n# fonctions renvoie un résultat \ndef fonction1():\n    print(\"Bonjour!\")\npremiere_fonction()\nOui!\n# fonctions renvoie un résultat \ndef nombre_carre(nombre): # argument nombre\n    print(nombre ** 2)\nnombre_carre(10)\n100\ndef nombre_puissance(nombre, puissance): # argument nombre\n    print(nombre ** puissance)\nnombre_puissance(10, 3) # donner les deux arguments !\n# nombre_puissance(5) # fonctionne pas\n1000\n# pratique pour utiliser les arguments dans l'ordre qu'on veut\nnombre_puissance(puissance = 3, nombre = 10) \n1000\n# fonction qui renvoie un nombre à la puissance\ndef nombre_puissance(nombre, puissance): \n    # documenter le code\n    \"\"\"\n    cette fonction calcule un nombre à la puissance et retourne le résultat.    \n    Parameters:    \n    nombre (int): le premier nombre \n    puissance (int): le deuxième nombre    \n    Returns:    int : nombre a la puissance     \n    \n    \"\"\"\n    return nombre ** puissance\n\n# interaction  avec un utilisateur \nnum = int(input(\"Saississez un nombre entier : \"))\npower = int(input(\"Saississez un nombre entier : \"))\n\nprint(\"Le résultat est :\", nombre_puissance(nombre = num, puissance = power))\n#Si premier nombre rentré = 10 et deuxieme nombre rentré = 3\n1000\nname = input(\"Enter your name:\")\nage = input(\"Enter your age:\")\n\nprint(\"Welcome,\",name, \"! you are now \", age)\n#Enter your name: Dorian \n#Enter your age: 26\nWelcome, Dorian ! you are now 26\n# Arguments arbitraire on ne connait pas le nombre de parametre à l'avance\ndef nombre_args(*nombre):\n    print(nombre[0]*nombre[1])\nnombre_args(5, 10, 4, 90)\n# Multiplication de l'argument à la position [O] = 5 etde l'agument à la position [1] = 10\n50\nargs_tuple = (5, 6, 8, 9)\nnombre_args(*args_tuple) # mettre etoile pour le tuple\n30\ndef nombre_puissance(nombre, puissance): # argument nombre\n    print(nombre ** puissance)\n# pratique pour définir des clé d'arguments\ndef nombre_kwarg(**nombre):\n    print('Mon age est : ' + nombre['age'] + ' et ma taille est : ' + nombre[\"taille\"])\nnombre_kwarg(age  = '26', taille = '1.75')\nMon age est : 26 et ma taille est : 1.75"
  },
  {
    "objectID": "fonctions.html#les-fonctions",
    "href": "fonctions.html#les-fonctions",
    "title": "Python",
    "section": "",
    "text": "Les boucles\n\n\nles fonctions sont des blocs de code qui sont exécutés lorsque vous les appelez. Vous pouvez personnaliser les fonctions pour qu’elles effectuent différentes tâches en leur passant différents arguments.\n\nDéfinies à l’aide du mot-clé **“def”*, suivi du nom de la fonction et de parenthèses.\nPasser des arguments aux fonctions pour fournir des valeurs d’entrée.\nLes arguments arbitraires et les mots-clés arbitraires sont utilisés lorsque vous ne savez pas à l’avance combien d’arguments vous allez passer.\n\narguments arbitraires, utilisez *args\nmots-clés arbitraires, utilisez **kwargs.\n\nChaque fonction doit être responsable d’une seule et unique fonctionnalité, et rien de plus.\n\n# fonctions renvoie un résultat \ndef fonction1():\n    print(\"Bonjour!\")\npremiere_fonction()\nOui!\n# fonctions renvoie un résultat \ndef nombre_carre(nombre): # argument nombre\n    print(nombre ** 2)\nnombre_carre(10)\n100\ndef nombre_puissance(nombre, puissance): # argument nombre\n    print(nombre ** puissance)\nnombre_puissance(10, 3) # donner les deux arguments !\n# nombre_puissance(5) # fonctionne pas\n1000\n# pratique pour utiliser les arguments dans l'ordre qu'on veut\nnombre_puissance(puissance = 3, nombre = 10) \n1000\n# fonction qui renvoie un nombre à la puissance\ndef nombre_puissance(nombre, puissance): \n    # documenter le code\n    \"\"\"\n    cette fonction calcule un nombre à la puissance et retourne le résultat.    \n    Parameters:    \n    nombre (int): le premier nombre \n    puissance (int): le deuxième nombre    \n    Returns:    int : nombre a la puissance     \n    \n    \"\"\"\n    return nombre ** puissance\n\n# interaction  avec un utilisateur \nnum = int(input(\"Saississez un nombre entier : \"))\npower = int(input(\"Saississez un nombre entier : \"))\n\nprint(\"Le résultat est :\", nombre_puissance(nombre = num, puissance = power))\n#Si premier nombre rentré = 10 et deuxieme nombre rentré = 3\n1000\nname = input(\"Enter your name:\")\nage = input(\"Enter your age:\")\n\nprint(\"Welcome,\",name, \"! you are now \", age)\n#Enter your name: Dorian \n#Enter your age: 26\nWelcome, Dorian ! you are now 26\n# Arguments arbitraire on ne connait pas le nombre de parametre à l'avance\ndef nombre_args(*nombre):\n    print(nombre[0]*nombre[1])\nnombre_args(5, 10, 4, 90)\n# Multiplication de l'argument à la position [O] = 5 etde l'agument à la position [1] = 10\n50\nargs_tuple = (5, 6, 8, 9)\nnombre_args(*args_tuple) # mettre etoile pour le tuple\n30\ndef nombre_puissance(nombre, puissance): # argument nombre\n    print(nombre ** puissance)\n# pratique pour définir des clé d'arguments\ndef nombre_kwarg(**nombre):\n    print('Mon age est : ' + nombre['age'] + ' et ma taille est : ' + nombre[\"taille\"])\nnombre_kwarg(age  = '26', taille = '1.75')\nMon age est : 26 et ma taille est : 1.75"
  },
  {
    "objectID": "boucles.html",
    "href": "boucles.html",
    "title": "Python",
    "section": "",
    "text": "Les boucles\n\n\nLa boucle for est utilisée pour parcourir des structures de données : liste, tuple, tableau, chaîne de caractères ou un dictionnaire.\n\nLa boucle commence par examiner le premier élément de la séquence, effectue des actions dans son corps, puis passe à l’élément suivant jusqu’à ce que la séquence soit terminée.\n\n\nBoucle avec mot-clé “for”, une variable temporaire pour contenir chaque élément, le mot-clé “in” et la séquence à parcourir, suivis de deux points. Jusqu’au bout de l’élément\nAppliquer des opérations sur la variable temporaire dans le corps de la boucle pour effectuer diverses opérations.\nImbriquer des for”\nSur les dictionnaires, on peut boucler sur les clés et les valeurs à l’aide de la méthode “items()”.\n\nLa boucle while itère sur un bloc de code tant qu’une condition spécifiée est vraie. Contrairement aux boucles “for”, les boucles “while” continuent l’itération tant que la condition reste vraie.\n\n“break” pour quitter prématurément une boucle “while”, même si la condition est toujours vraie.\n“else” peut être utilisée avec une boucle “while” pour spécifier un bloc de code qui s’exécutera lorsque la condition de la boucle ne sera plus vraie.\n“continue” permet d’ignorer le code restant dans l’itération actuelle de la boucle et de passer à l’itération suivante.\n!! Soyez prudent lorsque vous utilisez “continue” afin d’éviter de créer des boucles infinies.\n\nnombres = [16, 92, 120, 60, 21]\nfor num in nombres:\n    print(num)\n16 92 120 60 21\nfor hey in nombres:\n    print(hey)\n16 92 120 60 21\ndico = {'nom': 'Dorian', 'age': 26 , 'pates préférées' : ['Carbonara','Pesto']}\nfor d in dico.values():\n    print(d)\nDorian 26 [‘Carbonara’, ‘Pesto’]\nfor d in dico.keys():\n    print(d)\nnom age glaces préférées\nfor d in dico.keys():\n    print(d)\nnom -&gt; Dorian age -&gt; 26 pates préférées -&gt; [‘Carbonara’, ‘Pesto’]\n# while\nnumber = 0\nwhile number &lt; 100:\n        print(number)\n        number = number + 10\n0 10 20 30 40 50 60 70 80 90\nnumber = 0\nwhile number &lt; 50:\n        print(number)\n        if number == 30:\n            break\n        number = number + 10\n0 10 20 30\n# boucle qui se stop car prend la valeur +1 avant de s'afficher\nnumber = 0\nwhile number &lt; 50:\n    number = number + 10\n    if number == 30:\n        continue\n    print(number)\nelse:\n    print(\"ne satisfait plus la condition\")\n10 20 40 50 ne satisfait plus la condition\nwhile True: # gestion des erreurs\n    try: \n        x = int(input(\"Entrez un nombre entier : \")) \n        break \n    except ValueError: \n        print(\"Mince ! Ce n'est pas un nombre entier. Essayez encore...\")\n# Nombre rentré = 10.5\nMince ! Ce n’est pas un nombre entier. Essayez encore…"
  },
  {
    "objectID": "boucles.html#les-boucles",
    "href": "boucles.html#les-boucles",
    "title": "Python",
    "section": "",
    "text": "Les boucles\n\n\nLa boucle for est utilisée pour parcourir des structures de données : liste, tuple, tableau, chaîne de caractères ou un dictionnaire.\n\nLa boucle commence par examiner le premier élément de la séquence, effectue des actions dans son corps, puis passe à l’élément suivant jusqu’à ce que la séquence soit terminée.\n\n\nBoucle avec mot-clé “for”, une variable temporaire pour contenir chaque élément, le mot-clé “in” et la séquence à parcourir, suivis de deux points. Jusqu’au bout de l’élément\nAppliquer des opérations sur la variable temporaire dans le corps de la boucle pour effectuer diverses opérations.\nImbriquer des for”\nSur les dictionnaires, on peut boucler sur les clés et les valeurs à l’aide de la méthode “items()”.\n\nLa boucle while itère sur un bloc de code tant qu’une condition spécifiée est vraie. Contrairement aux boucles “for”, les boucles “while” continuent l’itération tant que la condition reste vraie.\n\n“break” pour quitter prématurément une boucle “while”, même si la condition est toujours vraie.\n“else” peut être utilisée avec une boucle “while” pour spécifier un bloc de code qui s’exécutera lorsque la condition de la boucle ne sera plus vraie.\n“continue” permet d’ignorer le code restant dans l’itération actuelle de la boucle et de passer à l’itération suivante.\n!! Soyez prudent lorsque vous utilisez “continue” afin d’éviter de créer des boucles infinies.\n\nnombres = [16, 92, 120, 60, 21]\nfor num in nombres:\n    print(num)\n16 92 120 60 21\nfor hey in nombres:\n    print(hey)\n16 92 120 60 21\ndico = {'nom': 'Dorian', 'age': 26 , 'pates préférées' : ['Carbonara','Pesto']}\nfor d in dico.values():\n    print(d)\nDorian 26 [‘Carbonara’, ‘Pesto’]\nfor d in dico.keys():\n    print(d)\nnom age glaces préférées\nfor d in dico.keys():\n    print(d)\nnom -&gt; Dorian age -&gt; 26 pates préférées -&gt; [‘Carbonara’, ‘Pesto’]\n# while\nnumber = 0\nwhile number &lt; 100:\n        print(number)\n        number = number + 10\n0 10 20 30 40 50 60 70 80 90\nnumber = 0\nwhile number &lt; 50:\n        print(number)\n        if number == 30:\n            break\n        number = number + 10\n0 10 20 30\n# boucle qui se stop car prend la valeur +1 avant de s'afficher\nnumber = 0\nwhile number &lt; 50:\n    number = number + 10\n    if number == 30:\n        continue\n    print(number)\nelse:\n    print(\"ne satisfait plus la condition\")\n10 20 40 50 ne satisfait plus la condition\nwhile True: # gestion des erreurs\n    try: \n        x = int(input(\"Entrez un nombre entier : \")) \n        break \n    except ValueError: \n        print(\"Mince ! Ce n'est pas un nombre entier. Essayez encore...\")\n# Nombre rentré = 10.5\nMince ! Ce n’est pas un nombre entier. Essayez encore…"
  },
  {
    "objectID": "module.html",
    "href": "module.html",
    "title": "Python",
    "section": "",
    "text": "Les modules en Python sont des fichiers contenant du code Python réutilisable.\n\nOrganiser le code en regroupant des fonctions, des classes et des variables connexes.\nImporter un module : ‘import’\nModules prêts à l’emploi pour des tâches diverses . ex : ‘NumPy’, ‘Pandas’, ‘Matplotlib’, ‘Seaborn’, ‘Scikit-Learn’, ‘TensorFlow’, ‘PyTorch’, ‘Django’, ‘Flask’, ‘Requests’\n\ndef somme(a, b):\n    return a + b\n\nresultat = somme(10, 5)\nprint(resultat)\n15\nfrom monpackage import operations\n\nresultat = operations.division(90, 10)\nprint(resultat)\n9.0\nfrom monpackage import operations\n\nresultat = operations.division(90, 10)\nprint(resultat)"
  },
  {
    "objectID": "module.html#module",
    "href": "module.html#module",
    "title": "Python",
    "section": "",
    "text": "Les modules en Python sont des fichiers contenant du code Python réutilisable.\n\nOrganiser le code en regroupant des fonctions, des classes et des variables connexes.\nImporter un module : ‘import’\nModules prêts à l’emploi pour des tâches diverses . ex : ‘NumPy’, ‘Pandas’, ‘Matplotlib’, ‘Seaborn’, ‘Scikit-Learn’, ‘TensorFlow’, ‘PyTorch’, ‘Django’, ‘Flask’, ‘Requests’\n\ndef somme(a, b):\n    return a + b\n\nresultat = somme(10, 5)\nprint(resultat)\n15\nfrom monpackage import operations\n\nresultat = operations.division(90, 10)\nprint(resultat)\n9.0\nfrom monpackage import operations\n\nresultat = operations.division(90, 10)\nprint(resultat)"
  },
  {
    "objectID": "exo.html#types",
    "href": "exo.html#types",
    "title": "Exercices",
    "section": "Types",
    "text": "Types"
  }
]